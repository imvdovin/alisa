use std::{
    collections::BTreeSet,
    fs::{self, File, OpenOptions},
    io::{Read, Seek, SeekFrom, Write},
    path::Path,
};

use anyhow::{Context, Result, ensure};
use fs2::FileExt;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use time::{OffsetDateTime, format_description::well_known::Rfc3339};
use uuid::Uuid;

/// Allowed workspace identifier format (documented for external systems).
pub const WORKSPACE_ID_PATTERN: &str = r"^ws_[0-9a-f]{32}$";

/// Schema version expected by the current binary.
pub const MANIFEST_SCHEMA_VERSION: &str = "1.0";

/// Default relative path for the main CLI configuration file.
pub const DEFAULT_CONFIG_PATH: &str = "alisa.toml";

/// Default relative path for local overrides that stay outside of VCS.
pub const DEFAULT_LOCAL_OVERRIDES_PATH: &str = "alisa.local.toml";

const WORKSPACE_ID_PREFIX: &str = "ws_";
const WORKSPACE_ID_SUFFIX_LEN: usize = 32;

/// Representation of the `paths` object inside `manifest.json`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ManifestPaths {
    pub config: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub local_overrides: Option<String>,
}

/// The root manifest describing the current workspace instance.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Manifest {
    pub schema_version: String,
    pub alisa_version: String,
    pub created_at: String,
    pub workspace_id: String,
    pub paths: ManifestPaths,
}

impl Manifest {
    /// Creates a brand-new manifest using the default schema and timestamp information.
    pub fn fresh() -> Self {
        Self {
            schema_version: MANIFEST_SCHEMA_VERSION.to_owned(),
            alisa_version: env!("CARGO_PKG_VERSION").to_owned(),
            created_at: current_timestamp(),
            workspace_id: generate_workspace_id(),
            paths: ManifestPaths {
                config: DEFAULT_CONFIG_PATH.to_owned(),
                local_overrides: Some(DEFAULT_LOCAL_OVERRIDES_PATH.to_owned()),
            },
        }
    }
}

/// Reads `manifest.json` if it exists. Returns `Ok(None)` when the file is missing.
pub fn read_manifest(path: &Path) -> Result<Option<Manifest>> {
    if !path.exists() {
        return Ok(None);
    }

    let data =
        fs::read(path).with_context(|| format!("Failed to read manifest at {}", path.display()))?;
    let manifest: Manifest = serde_json::from_slice(&data)
        .with_context(|| format!("Failed to parse manifest JSON at {}", path.display()))?;
    ensure_valid_workspace_id(&manifest.workspace_id, Some(path))?;
    Ok(Some(manifest))
}

/// Serializes and writes the provided manifest to disk.
pub fn write_manifest(path: &Path, manifest: &Manifest) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create manifest directory {}", parent.display()))?;
    }

    let json = serde_json::to_vec_pretty(manifest)?;
    fs::write(path, json)
        .with_context(|| format!("Failed to write manifest at {}", path.display()))?;

    Ok(())
}

/// Returns a default, empty `project.toml` snapshot stored under `.alisa/state`.
pub fn default_project_toml() -> String {
    format!(
        "# Generated by alisa init on {timestamp}\n[project]\nversion = 1\n",
        timestamp = current_timestamp()
    )
}

/// Returns a default runtime configuration stub.
pub fn default_runtime_toml() -> String {
    format!(
        "# Runtime parameters resolved on {timestamp}\n[runtime]\nprofile = \"default\"\n",
        timestamp = current_timestamp()
    )
}

/// Minimal JSON document for `state/session/current.json`.
pub fn default_session_state() -> Value {
    json!({
        "active_task": null,
        "updated_at": current_timestamp(),
        "runs": []
    })
}

/// Allocates a unique workspace identifier and persists it to the registry file.
pub fn allocate_workspace_id_and_record(path: &Path) -> Result<String> {
    modify_workspace_id_registry(path, |ids| {
        let next_id = generate_unique_workspace_id(ids);
        ids.insert(next_id.clone());
        Ok((true, next_id))
    })
}

/// Ensures that the provided workspace identifier exists in the registry file.
/// Returns true when the registry was updated.
pub fn ensure_workspace_id_recorded(path: &Path, id: &str) -> Result<bool> {
    ensure_valid_workspace_id(id, None)?;
    modify_workspace_id_registry(path, |ids| {
        let inserted = ids.insert(id.to_owned());
        Ok((inserted, inserted))
    })
}

/// Helper that formats the provided JSON in a human-friendly way.
pub fn to_pretty_json(value: &Value) -> Result<String> {
    serde_json::to_string_pretty(value).map_err(Into::into)
}

fn generate_workspace_id() -> String {
    format!("{WORKSPACE_ID_PREFIX}{}", Uuid::new_v4().simple())
}

fn generate_unique_workspace_id(existing: &BTreeSet<String>) -> String {
    loop {
        let candidate = generate_workspace_id();
        if !existing.contains(&candidate) {
            return candidate;
        }
    }
}

fn modify_workspace_id_registry<T, F>(path: &Path, op: F) -> Result<T>
where
    F: FnOnce(&mut BTreeSet<String>) -> Result<(bool, T)>,
{
    let mut file = lock_workspace_id_registry(path)?;
    let mut ids = read_registry_from_locked_file(path, &mut file)?;
    let (changed, value) = op(&mut ids)?;
    if changed {
        write_registry_to_locked_file(path, &mut file, &ids)?;
    }
    Ok(value)
}

/// Provides a cross-process critical section for workspace id mutations, so
/// parallel CLI invocations cannot clobber the registry snapshot.
fn lock_workspace_id_registry(path: &Path) -> Result<File> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| {
            format!(
                "Failed to create workspace id registry directory {}",
                parent.display()
            )
        })?;
    }

    let file = OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open(path)
        .with_context(|| format!("Failed to open workspace id registry at {}", path.display()))?;

    file.lock_exclusive()
        .with_context(|| format!("Failed to lock workspace id registry at {}", path.display()))?;

    Ok(file)
}

fn read_registry_from_locked_file(path: &Path, file: &mut File) -> Result<BTreeSet<String>> {
    file.seek(SeekFrom::Start(0))
        .with_context(|| format!("Failed to seek workspace id registry at {}", path.display()))?;

    let mut data = Vec::new();
    file.read_to_end(&mut data)
        .with_context(|| format!("Failed to read workspace id registry at {}", path.display()))?;

    if data.is_empty() || data.iter().all(u8::is_ascii_whitespace) {
        return Ok(BTreeSet::new());
    }

    let ids = serde_json::from_slice(&data).with_context(|| {
        format!(
            "Failed to parse workspace id registry at {}",
            path.display()
        )
    })?;

    Ok(ids)
}

fn write_registry_to_locked_file(
    path: &Path,
    file: &mut File,
    ids: &BTreeSet<String>,
) -> Result<()> {
    let data = serde_json::to_vec_pretty(ids)?;

    file.set_len(0).with_context(|| {
        format!(
            "Failed to truncate workspace id registry at {}",
            path.display()
        )
    })?;
    file.seek(SeekFrom::Start(0))
        .with_context(|| format!("Failed to seek workspace id registry at {}", path.display()))?;
    file.write_all(&data).with_context(|| {
        format!(
            "Failed to write workspace id registry at {}",
            path.display()
        )
    })?;
    file.flush().with_context(|| {
        format!(
            "Failed to flush workspace id registry at {}",
            path.display()
        )
    })?;
    Ok(())
}

fn ensure_valid_workspace_id(id: &str, path: Option<&Path>) -> Result<()> {
    ensure!(
        is_valid_workspace_id(id),
        "Invalid workspace_id '{}'{} (expected pattern {})",
        id,
        match path {
            Some(p) => format!(" in manifest at {}", p.display()),
            None => String::new(),
        },
        WORKSPACE_ID_PATTERN,
    );
    Ok(())
}

fn is_valid_workspace_id(id: &str) -> bool {
    if !id.starts_with(WORKSPACE_ID_PREFIX) {
        return false;
    }

    let suffix = &id[WORKSPACE_ID_PREFIX.len()..];
    if suffix.len() != WORKSPACE_ID_SUFFIX_LEN {
        return false;
    }

    suffix.chars().all(|ch| matches!(ch, '0'..='9' | 'a'..='f'))
}

fn current_timestamp() -> String {
    let now = OffsetDateTime::now_utc();
    match now.format(&Rfc3339) {
        Ok(timestamp) => timestamp,
        Err(err) => {
            eprintln!("[warn] Failed to format timestamp in RFC3339: {err}");
            now.to_string()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::{
        sync::{
            Arc,
            atomic::{AtomicBool, Ordering},
        },
        thread,
        time::Duration,
    };
    use tempfile::tempdir;

    #[test]
    fn generated_ids_match_pattern() {
        for _ in 0..64 {
            let id = generate_workspace_id();
            assert!(
                is_valid_workspace_id(&id),
                "generated id {id} must be valid"
            );
        }
    }

    #[test]
    fn validation_checks_allowed_characters() {
        let valid = "ws_0123456789abcdef0123456789abcdef";
        assert!(is_valid_workspace_id(valid));

        let upper = "ws_0123456789ABCDEF0123456789abcdef";
        assert!(!is_valid_workspace_id(upper));

        let long = "ws_0123456789abcdef0123456789abcdef0";
        assert!(!is_valid_workspace_id(long));
    }

    #[test]
    fn workspace_id_registry_persists_entries() {
        let temp = tempdir().expect("temp dir");
        let registry_path = temp.path().join("workspace_ids.json");

        let first = allocate_workspace_id_and_record(&registry_path).expect("first id");
        assert!(registry_path.exists(), "registry file must be created");

        let second = allocate_workspace_id_and_record(&registry_path).expect("second id");
        assert_ne!(first, second, "subsequent ids must differ");

        let registry_data: BTreeSet<String> =
            serde_json::from_slice(&fs::read(&registry_path).unwrap()).unwrap();
        assert!(registry_data.contains(&first));
        assert!(registry_data.contains(&second));

        let updated = ensure_workspace_id_recorded(&registry_path, &first).expect("no-op record");
        assert!(!updated, "re-recording same id should be a no-op");
    }

    #[test]
    fn ensure_workspace_id_recorded_respects_file_lock() {
        let temp = tempdir().expect("temp dir");
        let registry_path = temp.path().join("workspace_ids.json");

        let locked_file = lock_workspace_id_registry(&registry_path).expect("lock registry");

        let blocked = Arc::new(AtomicBool::new(false));
        let finished = Arc::new(AtomicBool::new(false));

        let thread_path = registry_path.clone();
        let thread_blocked = blocked.clone();
        let thread_finished = finished.clone();

        let handle = thread::spawn(move || {
            thread_blocked.store(true, Ordering::SeqCst);
            let inserted = ensure_workspace_id_recorded(&thread_path, &generate_workspace_id())
                .expect("ensure must succeed once lock released");
            thread_finished.store(true, Ordering::SeqCst);
            inserted
        });

        // Give the spawned thread time to attempt locking the file.
        let mut waited = 0;
        while !blocked.load(Ordering::SeqCst) && waited < 10 {
            thread::sleep(Duration::from_millis(10));
            waited += 1;
        }

        thread::sleep(Duration::from_millis(50));
        assert!(blocked.load(Ordering::SeqCst), "worker thread must start");
        assert!(
            !finished.load(Ordering::SeqCst),
            "ensure_workspace_id_recorded should block until lock is free"
        );

        drop(locked_file);

        assert!(handle.join().expect("thread must finish"));
        assert!(finished.load(Ordering::SeqCst));
    }
}

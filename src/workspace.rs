use std::{
    fs::{self, File, OpenOptions},
    io,
    path::{Component, Path, PathBuf},
    thread,
    time::Duration,
};

use anyhow::{Context, Result, bail};
use fs2::FileExt;

/// Name of the workspace directory that lives inside every project root.
pub const WORKSPACE_DIR_NAME: &str = ".alisa";

/// Relative paths of directories that must always exist inside `.alisa`.
pub const REQUIRED_DIRECTORIES: &[&str] = &[
    "locks",
    "state",
    "state/session",
    "tasks",
    "audit",
    "audit/runs",
    "cache",
    "cache/rag",
    "cache/web",
    "cache/python",
    "migrations",
];

/// Default `.gitignore` contents scoped to the `.alisa` directory.
pub const DEFAULT_GITIGNORE: &str = r#"# Generated by alisa init
state/session/
cache/
audit/runs/
audit/history-*.ndjson.zst
*.sqlite-journal
*.sqlite-wal
"#;

/// Helper struct that resolves absolute paths inside the workspace directory.
#[derive(Debug, Clone)]
pub struct Workspace {
    project_root: PathBuf,
}

/// Guard object returned when the workspace lock has been acquired.
pub struct WorkspaceLock {
    file: File,
    path: PathBuf,
}

impl Drop for WorkspaceLock {
    fn drop(&mut self) {
        let mut attempt = 0usize;
        let path = self.path.clone();
        if let Err(err) = unlock_with_retry(|| {
            attempt += 1;
            match self.file.unlock() {
                Ok(()) => Ok(()),
                Err(err) => {
                    eprintln!(
                        "[warn] Failed to release workspace lock at {} (attempt {attempt}/{UNLOCK_RETRY_ATTEMPTS}): {err}",
                        path.display()
                    );
                    Err(err)
                }
            }
        }) {
            eprintln!(
                "[warn] Giving up on releasing workspace lock at {} after {attempt} attempts: {err}",
                path.display()
            );
        }
    }
}

impl WorkspaceLock {
    fn new(file: File, path: PathBuf) -> Self {
        Self { file, path }
    }
}

const UNLOCK_RETRY_ATTEMPTS: usize = 3;
const UNLOCK_RETRY_DELAY: Duration = Duration::from_millis(50);

fn unlock_with_retry<F>(mut unlock_op: F) -> io::Result<()>
where
    F: FnMut() -> io::Result<()>,
{
    let mut last_err: Option<io::Error> = None;
    for attempt in 1..=UNLOCK_RETRY_ATTEMPTS {
        match unlock_op() {
            Ok(()) => return Ok(()),
            Err(err) => {
                last_err = Some(err);
                if attempt != UNLOCK_RETRY_ATTEMPTS {
                    thread::sleep(UNLOCK_RETRY_DELAY);
                }
            }
        }
    }

    Err(last_err.unwrap_or_else(|| io::Error::other("unlock failed")))
}

impl Workspace {
    /// Builds a new workspace representation rooted at the provided path.
    pub fn new(root: impl Into<PathBuf>) -> Self {
        Self {
            project_root: root.into(),
        }
    }

    /// Creates a workspace using the current working directory as the project root.
    pub fn detect_from_cwd() -> Result<Self> {
        let cwd = std::env::current_dir().context("Failed to read current directory")?;
        Ok(Self::new(cwd))
    }

    /// Returns the absolute path to `.alisa` inside the project root.
    pub fn workspace_root(&self) -> PathBuf {
        self.project_root.join(WORKSPACE_DIR_NAME)
    }

    /// Computes an absolute path for a relative entry inside `.alisa`.
    pub fn join(&self, relative: &str) -> Result<PathBuf> {
        let normalized = Self::normalize_relative_path(relative)?;
        let mut path = self.workspace_root();
        path.push(normalized);
        Ok(path)
    }

    /// Path to `manifest.json`.
    pub fn manifest_path(&self) -> PathBuf {
        self.join("manifest.json")
            .expect("manifest path is a fixed entry inside the workspace")
    }

    /// Path to `.gitignore` inside `.alisa`.
    pub fn gitignore_path(&self) -> PathBuf {
        self.join(".gitignore")
            .expect(".gitignore path is a fixed entry inside the workspace")
    }

    /// Path to the cooperative lock file under `.alisa/locks`.
    pub fn lock_path(&self) -> PathBuf {
        self.join("locks/workspace.lock")
            .expect("lock path is a fixed entry inside the workspace")
    }

    /// Path to the registry SQLite database.
    pub fn registry_path(&self) -> PathBuf {
        self.join("state/registry.sqlite")
            .expect("registry path is a fixed entry inside the workspace")
    }

    /// Path to the workspace id registry snapshot.
    pub fn workspace_id_registry_path(&self) -> PathBuf {
        self.join("state/workspace_ids.json")
            .expect("workspace id registry path is a fixed entry inside the workspace")
    }

    /// Path to the audit index database.
    pub fn audit_index_path(&self) -> PathBuf {
        self.join("audit/audit_index.sqlite")
            .expect("audit index path is a fixed entry inside the workspace")
    }

    /// Path to the RAG full-text index SQLite database.
    pub fn rag_index_path(&self) -> PathBuf {
        self.join("cache/rag/index.sqlite")
            .expect("rag index path is a fixed entry inside the workspace")
    }

    /// Path to the schema version marker inside `migrations/`.
    pub fn schema_version_path(&self) -> PathBuf {
        self.join("migrations/version.txt")
            .expect("schema version path is a fixed entry inside the workspace")
    }

    /// Returns all absolute directory paths that must exist.
    pub fn directory_targets(&self) -> Vec<PathBuf> {
        let mut dirs = Vec::with_capacity(REQUIRED_DIRECTORIES.len() + 1);
        dirs.push(self.workspace_root());
        dirs.extend(REQUIRED_DIRECTORIES.iter().map(|rel| {
            self.join(rel)
                .expect("required directories are fixed entries inside the workspace")
        }));
        dirs
    }

    /// Path to the project configuration snapshot inside `.alisa/state`.
    pub fn project_snapshot_path(&self) -> PathBuf {
        self.join("state/project.toml")
            .expect("project snapshot path is a fixed entry inside the workspace")
    }

    /// Path to the runtime configuration snapshot inside `.alisa/state`.
    pub fn runtime_snapshot_path(&self) -> PathBuf {
        self.join("state/runtime.toml")
            .expect("runtime snapshot path is a fixed entry inside the workspace")
    }

    /// Path to the session state JSON file.
    pub fn session_state_path(&self) -> PathBuf {
        self.join("state/session/current.json")
            .expect("session state path is a fixed entry inside the workspace")
    }

    fn prepare_lock_file(&self) -> Result<File> {
        let path = self.lock_path();
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create lock directory {}", parent.display()))?;
        }

        match Self::open_lock_file(&path) {
            Ok(file) => Ok(file),
            Err(err) => {
                self.recover_lock_file(&path, &err)?;
                Self::open_lock_file(&path).with_context(|| {
                    format!("Failed to open lock file {} after recovery", path.display())
                })
            }
        }
    }

    fn open_lock_file(path: &Path) -> io::Result<File> {
        OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(path)
    }

    fn recover_lock_file(&self, path: &Path, original_error: &io::Error) -> Result<()> {
        Self::remove_lock_obstacle(path).with_context(|| {
            format!(
                "Failed to remove damaged lock path {} (original error: {original_error})",
                path.display()
            )
        })?;
        Ok(())
    }

    fn normalize_relative_path(relative: &str) -> Result<PathBuf> {
        let mut normalized = PathBuf::new();
        for component in Path::new(relative).components() {
            match component {
                Component::Prefix(_) | Component::RootDir => {
                    bail!("Path '{relative}' must stay inside the workspace root");
                }
                Component::CurDir => {}
                Component::Normal(part) => normalized.push(part),
                Component::ParentDir => {
                    if !normalized.pop() {
                        bail!("Path '{relative}' must stay inside the workspace root");
                    }
                }
            }
        }
        Ok(normalized)
    }

    fn remove_lock_obstacle(path: &Path) -> io::Result<()> {
        match fs::metadata(path) {
            Ok(metadata) => {
                if metadata.is_file() {
                    fs::remove_file(path)
                } else {
                    fs::remove_dir_all(path)
                }
            }
            Err(err) if err.kind() == io::ErrorKind::NotFound => Ok(()),
            Err(err) => {
                // Attempt best-effort cleanup even if metadata failed (e.g. dangling symlink).
                if matches!(err.kind(), io::ErrorKind::PermissionDenied) {
                    // Try removing as file first, then directory. Propagate the original error if both fail.
                    fs::remove_file(path)
                        .or_else(|_| fs::remove_dir_all(path))
                        .or(Err(err))
                } else {
                    Err(err)
                }
            }
        }
    }

    /// Attempts to take the cooperative lock without blocking. Returns `Ok(None)` if already held.
    pub fn try_acquire_lock(&self) -> Result<Option<WorkspaceLock>> {
        let file = self.prepare_lock_file()?;
        let lock_path = self.lock_path();
        match file.try_lock_exclusive() {
            Ok(()) => Ok(Some(WorkspaceLock::new(file, lock_path))),
            Err(err) if err.kind() == io::ErrorKind::WouldBlock => Ok(None),
            Err(err) => Err(err).with_context(|| {
                format!(
                    "Failed to try locking workspace at {}",
                    self.lock_path().display()
                )
            }),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::{cell::Cell, io};
    use tempfile::tempdir;

    #[test]
    fn join_normalizes_relative_paths() {
        let temp = tempdir().expect("temp dir");
        let workspace = Workspace::new(temp.path());

        let path = workspace
            .join("state/../locks/workspace.lock")
            .expect("normalized path");
        let root = workspace.workspace_root();
        assert!(path.starts_with(&root));
        assert!(path.ends_with("locks/workspace.lock"));
    }

    #[test]
    fn join_rejects_traversal_outside_workspace() {
        let temp = tempdir().expect("temp dir");
        let workspace = Workspace::new(temp.path());

        let err = workspace
            .join("../../etc/passwd")
            .expect_err("path traversal must be rejected");
        assert!(
            err.to_string().contains("workspace root"),
            "error message should mention workspace boundaries"
        );
    }

    #[test]
    fn join_rejects_absolute_paths() {
        let temp = tempdir().expect("temp dir");
        let workspace = Workspace::new(temp.path());

        workspace
            .join("/tmp/evil")
            .expect_err("absolute paths must be rejected");
    }

    #[test]
    fn cooperative_lock_blocks_second_holder() {
        let temp = tempdir().expect("temp dir");
        let workspace = Workspace::new(temp.path());

        let first_guard = workspace
            .try_acquire_lock()
            .expect("lock attempt")
            .expect("first lock must succeed");

        assert!(
            workspace
                .try_acquire_lock()
                .expect("lock attempt")
                .is_none(),
            "second lock attempt should report lock is already held"
        );

        drop(first_guard);

        assert!(
            workspace
                .try_acquire_lock()
                .expect("lock attempt")
                .is_some(),
            "lock should be reacquired after release"
        );
    }

    #[test]
    fn lock_recovers_from_directory_path() {
        let temp = tempdir().expect("temp dir");
        let workspace = Workspace::new(temp.path());

        // Simulate a corrupted lock path that became a directory.
        let lock_path = workspace.lock_path();
        fs::create_dir_all(&lock_path).expect("create fake lock dir");

        let guard = workspace
            .try_acquire_lock()
            .expect("lock attempt")
            .expect("lock should be recreated");
        drop(guard);

        let metadata = fs::metadata(&workspace.lock_path()).expect("lock metadata");
        assert!(
            metadata.is_file(),
            "lock path must be a regular file after recovery"
        );
    }

    #[test]
    fn unlock_retries_until_success() {
        let attempts = Cell::new(0);
        let result = super::unlock_with_retry(|| {
            let current = attempts.get() + 1;
            attempts.set(current);
            if current < super::UNLOCK_RETRY_ATTEMPTS {
                Err(io::Error::other("still locked"))
            } else {
                Ok(())
            }
        });

        assert!(result.is_ok(), "unlock must eventually succeed");
        assert_eq!(
            attempts.get(),
            super::UNLOCK_RETRY_ATTEMPTS,
            "must retry until final attempt"
        );
    }

    #[test]
    fn unlock_reports_error_after_exhaustion() {
        let attempts = Cell::new(0);
        let result = super::unlock_with_retry(|| {
            attempts.set(attempts.get() + 1);
            Err(io::Error::other("permanent failure"))
        });

        assert!(result.is_err(), "unlock must surface error after retries");
        assert_eq!(
            attempts.get(),
            super::UNLOCK_RETRY_ATTEMPTS,
            "must attempt maximum number of retries"
        );
    }
}
